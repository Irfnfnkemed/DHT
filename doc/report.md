# Report

## **Chord**
### 文件结构
* **`chord/chord.go`**:
实现chord的主体部分，包括节点的插入、退出，数据的插入、查找、删除，以及环结构的维护。
* **`chord/rpcWrapper.go`**:
包裹`chord.go`中需要用到的远端调用的函数，便于注册服务和控制。
* **`chord/tool.go`**:
包括了一些辅助方法。
* **`rpc/rpc.go`**:
实现了用户池(client pool)，在节点初始化时建立永久连接，避免运行时每次远端调用都重新建立连接，节约了大量时间。

### 一些细节与想法
* 由于用户池的建立需要一定的时间，因此在调用`Run`后，需要阻塞节点的 `Create`或`Join`，防止因连接未建立完毕而产生死锁。另外，对于一个`*rpc.Client`对象，其与`*rpc.Server`的连接只需`Accept`一次，同时为了防止资源泄漏，应该保留所有用于建立连接的`conn`对象，在结束时释放。
* 判定某地址是否属于目标区间时，若目标区间的上下界重合，则由于环结构，应该认为地址是否属于目标区间（除非区间两端开，且目标恰与区间上下界重合），否则找前驱时会造成死循环。
* `Quit`函数需要更改前驱后继的环指向，并转移数据。为了防止在更改转移过程中，`Stabilize`对过程造成不可控的影响(如后继在更新前驱之前，发现原前驱下线，认为其异常退出，执行数据恢复；如当前节点进行`Stabilize`导致环结构被错误改回)，需要在操作前阻塞当前、前驱、后继的`Stabilize`进程，待环结构重构后再重新解除阻塞。另外，需要特判前驱后继是否相同、是否是自己，防止死锁。
* `Stabilize`时，若发现后继是自己，也需要更改后继，否则会死循环。这主要是针对环结构初步形成时(如刚加入第二个节点)的情况。
* `Stabilize`的频率需要反复测试，若频率过低，则修复能力过弱；若太高，则容易与其他函数发生纠缠。
* `FixFinger`时，若发现路由表指向的对象已下线，则更改其为上线的节点，防止死循环。
* 数据的转移的原因有三：`Join`，`Quit`，`ForceQuit`。对于加入，在`Stablize`更改后继时转移数据；对于正常退出，直接在进程中完成转移；对于异常退出，在`Stablize`中，后继尝试得到前驱时，检测到前驱下线，便利用备份进程数据恢复。

## **Kademlia**
### 文件结构
* **`kademlia/kademlia.go`**:
实现kademlia的主体部分，包括节点的插入、退出，数据的插入、查找、删除，以及结构的维护。
* **`kademlia/bucket.go`**:
实现kademlia中的桶结构，包括对桶的各种操作和维护。
* **`kademlia/data.go`**:
维护kademlia的数据，包括重新发布时间与丢弃时间。
* **`kademlia/rpcWrapper.go`**:
包裹`chord.go`中需要用到的远端调用的函数，便于注册服务和控制。
* **`kademlia/tool.go`**:
包括了一些辅助方法，以及`NodeLookup`,`Get`中所使用的类似于`std::set`的结构。
* **`rpc/rpc.go`**:
同chord部分。
### 一些细节与想法
* 桶、`tool.Order`(用于`NodeLookup`,`Get`)中的元素均为有序排列，且大量涉及插入、删除、移动操作，因此选用链表来作为实现结构。
* 由于Kademlia涉及大量对同一节点的桶的同时操作，故对桶的上锁需要格外谨慎。另外，需要注意在同一函数中，两次上锁解锁之间，由于并发运行，因此先前拿出的临时变量可能并不代表此时真实的值，这意味着需要相应地做出错误判断与处理。
* 在`Ping`成功之后，不应该对发起端和被调用端的桶进行更新。因为在发现新的沟通后，节点会试图将其加入桶，而当桶已经满时，节点会尝试`Ping`桶中最不常联系的节点。因此，若在`Ping`成功之后，发起端和被调用端的桶进行更新，更新的过程又可能会调用`Ping`，然后再次试图更新，如此往复，造成死循环。
* Kademlia中有大量可以并发执行的操作，比如`Republish`时可以并发地对所有相应的数据进行重发、`Put`时确定数据存储的目标节点后，可以并发地向各节点发送存储请求。这样可以提高效率。
* 重新发布时间、舍弃时间、`maintain`中的相关检测周期的时间都需要反复测试。否则，可能发生数据未及时转移、数据被异常舍弃、与`Put`、`Get`等发生严重竞争等错误情况。