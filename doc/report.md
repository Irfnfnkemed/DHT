# Report

## Chord
### 文件结构
* **`chord/chord.go`**:
实现chord的主体部分，包括节点的插入、退出，数据的插入、查找、删除，以及环结构的维护。同时还包括了一些辅助方法。
* **`chord/rpc_wrapper.go`**:
包裹`chord.go`中需要用到的远端调用的函数，便于注册服务和控制。
* **`rpc/rpc.go`**:
实现了用户池(client pool)，在节点初始化时建立永久连接，避免运行时每次远端调用都重新建立连接，节约了大量时间。

### 一些细节与想法
* 由于用户池的建立需要一定的时间，因此在调用`Run`后，需要阻塞节点的 `Create`或`Join`，防止因连接未建立完毕而产生死锁。另外，对于一个`*rpc.Client`对象，其与`*rpc.Server`的连接只需`Accept`一次，同时为了防止资源泄漏，应该保留所有用于建立连接的`conn`对象，在结束时释放。
* 判定某地址是否属于目标区间时，若目标区间的上下界重合，则由于环结构，应该认为地址是否属于目标区间（除非区间两端开，且目标恰与区间上下界重合），否则找前驱时会造成死循环。
* `Quit`函数需要更改前驱后继的环指向，并转移数据。为了防止在更改转移过程中，`Stabilize`对过程造成不可控的影响(如后继在更新前驱之前，发现原前驱下线，认为其异常退出，执行数据恢复；如当前节点进行`Stabilize`导致环结构被错误改回)，需要在操作前阻塞当前、前驱、后继的`Stabilize`进程，待环结构重构后再重新解除阻塞。另外，需要特判前驱后继是否相同、是否是自己，防止死锁。
* `Stabilize`时，若发现后继是自己，也需要更改后继，否则会死循环。这主要是针对环结构初步形成时(如刚加入第二个节点)的情况。
* `Stabilize`的频率需要反复测试，若频率过低，则修复能力过弱；若太高，则容易与其他函数发生纠缠。
* `Fix_finger`时，若发现路由表指向的对象已下线，则更改其为上线的节点，防止死循环。
* 数据的转移的原因有三：`Join`，`Quit`，`ForceQuit`。对于加入，在`Stablize`更改后继时转移数据；对于正常退出，直接在进程中完成转移；对于异常退出，在`Stablize`中，后继尝试得到前驱时，检测到前驱下线，便利用备份进程数据恢复。